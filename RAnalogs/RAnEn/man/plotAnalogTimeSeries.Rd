% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotAnalogTimeSeries.R
\name{plotAnalogTimeSeries}
\alias{plotAnalogTimeSeries}
\title{RAnEn::plotAnalogTimeSeries}
\usage{
plotAnalogTimeSeries(
  start.time,
  end.time,
  i.station,
  obs.id,
  obs.times,
  obs.data,
  anen.times,
  anen.flts,
  anen.data,
  fcst.id = NULL,
  fcst.times = NULL,
  fcst.flts = NULL,
  fcst.data = NULL,
  max.flt = 82800,
  par.name = "",
  return.data = F,
  smooth = 4
)
}
\arguments{
\item{start.time}{A POSIXct for the start time.}

\item{end.time}{A POSIXct for the end time.}

\item{i.station}{The station index to visualize. This can
be a single scalar so that the same station index for
observations, AnEn, and forecasts is used; or it can be
a named vector like this:
\code{i.station = c('obs' = 4, 'anen' = 15, 'fcst' = 10)} or
\code{i.station = c('obs' = 4, 'anen' = 15)}.}

\item{obs.id}{The observation parameter ID.}

\item{obs.times}{A vector for observation times. Usually
this is \code{observations$Times}.}

\item{obs.data}{An array for observation data. Usually
this is \code{observations$Data}.}

\item{anen.times}{A vector for AnEn times. Usually
this is \code{config$test_time_compares}.}

\item{anen.flts}{A vector for AnEn flts. Usually
this is \code{config$flts}.}

\item{anen.data}{An array for AnEn data. Usually
this is \code{AnEn$analogs[, , , , 1]}}

\item{fcst.id}{The forecast parameter ID.}

\item{fcst.times}{A vector for forecast times. Usually
this is \code{forecasts$Times}.}

\item{fcst.flts}{A vector for forecast flts. Usually
this is \code{forecasts$flts}.}

\item{fcst.data}{An array for forecast data. Usually
this is \code{forecasts$Data}.}

\item{max.flt}{The cut off point value for both
forecasts and AnEn lead times.}

\item{par.name}{The variable name to be shown on figures.}

\item{return.data}{Whether to return the plot data
so that you can generate your own plots. This will
suppress plotting the figure inside this function.}
}
\value{
If \code{return.data} is TRUE, a list with two
data frames is returned; otherwise, it returns a ggplot
object.
}
\description{
RAnEn::plotAnalogTimeSeries plots forecasts and observations
for comparison over time.
}
\details{
Sometimes, it is helpful to plot forecasts and observations
for a long time series. However, this is always limited
by forecast lead times because the lead times are usually
for several days. What if we want to plot a time series that
spans longer than that?

This function generates a plot for that purpose. It simply
stacks forecasts from different days and all forecasts lead
times. Overlapping lead times will be cut off and earlier
lead times will be preferred and kept.
}
\examples{
\dontrun{
# If you have already generated AnEn by using the 
# function RAnEn::generateAnalogs, you probably already
# have the followings or the equivalents:
# 
# - observations (An observation list with members)
# - config (The configuration used for AnEn generation)
# - forecasts (A forecast list with members)
# 
# Then you can run the following code
# 

# Want to learn more about the configuration setup?
# Please see [this tutorial](https://weiming-hu.github.io/AnalogsEnsemble/2018/11/04/demo-1-RAnEn-basics.html).
# 
file.name <- 'data-NAM-StateCollege.RData'

if (!file.exists(file.name)) {
  cat('Downloading from the data server which might be slow ...\n')
  download.file(url = paste('https://prosecco.geog.psu.edu/', file.name, sep = ''),
                destfile = file.name)
}

load(file.name)

# We use independent search configuration.
config <- generateConfiguration('independentSearch')

# Set up the start and end indices for test times
test.start <- 366
test.end <- 372

# Set up the start and end indices for search times
search.start <- 1
search.end <- 365

# Set up forecasts and the time, FLT information
config$forecasts <- forecasts$Data
config$forecast_times <- forecasts$Times
config$flts <- forecasts$FLTs

# Set up observations and the time information
config$search_observations <- observations$Data
config$observation_times <- observations$Times

# Set up the number of members to keep in the analog ensemble
# Empirically, the number of members is the square root of number of search times.
config$num_members <- sqrt(search.end - search.start + 1)

# Set up the variable that we want to generate AnEn for.
# This is the index of parameter in observation parameter names.
#
obs.id <- 3
fcst.id <- 3
config$observation_id <- obs.id

# Set up weights for each parameters
config$weights <- c(1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1)

# Set the test times to generate AnEn for
config$test_times_compare <- forecasts$Times[test.start:test.end]

# Set the search times to generate AnEn from
config$search_times_compare <- forecasts$Times[search.start:search.end]

# Set circular variable if there is any
if ('ParameterCirculars' \%in\% names(forecasts)) {
  config$circulars <- unlist(lapply(forecasts$ParameterCirculars, function(x) {
    return(which(x == forecasts$ParameterNames))}))
}

AnEn <- generateAnalogs(config)

start.time <- as.POSIXct('2018-06-01', tz = 'UTC')
end.time <- as.POSIXct('2018-06-07', tz = 'UTC')

obs.times <- observations$Times
obs.data <- observations$Data

anen.times <- config$test_times_compare
anen.flts <- config$flts
anen.data <- AnEn$analogs[, , , , 1]

fcst.times <- forecasts$Times
fcst.flts <- config$flts
fcst.data <- forecasts$Data

# fcst.id <- NULL
# fcst.times <- NULL
# fcst.flts <- NULL
# fcst.data <- NULL

i.station <- 14

par.name <- observations$ParameterNames[obs.id]

plotAnalogTimeSeries(
  start.time, end.time, i.station,
  obs.id, obs.times, obs.data,
  anen.times, anen.flts, anen.data,
  fcst.id, fcst.times, fcst.flts, fcst.data,
  par.name = par.name)
}

}
