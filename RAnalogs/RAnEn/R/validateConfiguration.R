# "`-''-/").___..--''"`-._
#  (`6_ 6  )   `-.  (     ).`-.__.`)   WE ARE ...
#  (_Y_.)'  ._   )  `._ `. ``-..-'    PENN STATE!
#    _ ..`--'_..-_/  /--'_.' ,'
#  (il),-''  (li),'  ((!.-'
# 
# Author: Weiming Hu <weiming@psu.edu>
#         Geoinformatics and Earth Observation Laboratory (http://geolab.psu.edu)
#         Department of Geography and Institute for CyberScience
#         The Pennsylvania State University
#

#' RAnEn::validateConfiguration
#' 
#' RAnEn::validateConfiguration validates the configuration object created by
#' the function \code{\link{generateConfiguration}}.
#' 
#' @author Weiming Hu \email{weiming@@psu.edu}
#' 
#' @param x A configuration object generated by the function
#' \code{\link{generateConfiguration}}.
#' 
#' @return A boolean whether the configuration object is fully configured and
#' ready to be used in computation.
#' 
#' @export
validateConfiguration <- function(x) {
  
  # Check input class
  if (class(x) != 'Configuration') stop("The input is not a Configuration.")
  
  # The return valid of this function
  valid <- T
  
  # Check for deprecation
  if ("search_flts" %in% names(x)) {
    stop("'search_flts' is deprecated and renamed to 'flts'. Please rename search_flts to flts.")
  }
  
  # Naive checks for whether the configuration has the correct basic or advanced format  
  if (all(c("forecasts", "test_forecasts") %in% names(x))) {
    cat("Error: Confusing configuration. Forecasts and test_forecasts should not exist at the same time.\n")
    cat('Please recreate the configuration object using RAnEn::generateConfiguration.\n')
    valid <- F
  }
  
  if ("test_forecasts" %in% names(x) && x$advanced) {
    # This is expected
  } else if ("forecasts" %in% names(x) && !x$advanced) {
    # This is expected
  } else {
    cat("Error: Confusing configuration. Did you manually change any member names in the configuration?\n")
    cat('Please recreate the configuration object using RAnEn::generateConfiguration.\n')
    valid <- F
  }
  
  # NULL is not allowed for these required members
  required.members <- c('num_members', 'search_observations', 'observation_times', 'flts')
  
  if (x$advanced) {
    required.members <- c(required.members, 'test_forecasts', 'test_times', 'search_forecasts', 'search_times')
  } else {
    required.members <- c(required.members, 'forecasts', 'forecast_times')
  }
  
  if (x$mode == 'extendedSearch') {
    if (x$advanced) {
      required.members <- c(required.members, 'test_stations_x', 'test_stations_y',
                            'search_stations_x', 'search_stations_y')
    } else {
      required.members <- c(required.members, 'forecast_stations_x', 'forecast_stations_y')
    }
  }
  
  for (name in required.members) {
    if (is.null(x[[name]])) {
      cat("Required variable:", name, "\n")
      valid <- F
    }
  }
  
  if (!valid) return(valid)
  
  # Prepare variable names to check from basic/advanced configuration.
  # 
  # The names of the each element indicates what the element
  # stands for; the element is the name in the configuration that 
  # should be checked.
  # 
  names.to.check <- vector('character', 4)
  names(names.to.check) <- c('test_forecasts', 'search_forecasts', 'test_times', 'search_times')
  if (x$mode == 'extendedSearch') {
    names.to.check <- c(names.to.check, vector('character', 4))
    names(names.to.check)[5:8] <- c('test_stations_x', 'search_stations_x',
                                    'test_stations_y', 'search_stations_y')
  }
  
  if (x$advanced) {
    names.to.check[1:4] <- c('test_forecasts', 'search_forecasts', 'test_times', 'search_times')
    
    if (x$mode == 'extendedSearch') {
      names.to.check[5:8] <- c('test_stations_x', 'search_stations_x',
                               'test_stations_y', 'search_stations_y')
    }
    
  } else {
    names.to.check[1:4] <- c('forecasts', 'forecasts', 'forecast_times', 'forecast_times')
    
    if (x$mode == 'extendedSearch') {
      names.to.check[5:8] <- c('forecast_stations_x', 'forecast_stations_x',
                               'forecast_stations_y', 'forecast_stations_y')
    }
  }
  
  # Check the mode
  if (!(x$mode %in% c('extendedSearch', 'independentSearch'))) {
    cat('Error: Unknown configuration mode! Did you change it manually?\n')
    valid <- F
  }
  
  # Make sure the elements in names.to.check exist in the configuration
  for (name in names.to.check) {
    if (!(name %in% names(x))) {
      cat("Error: Missing configuration '", name, "'.\n")
      valid <- F
    }
  }
  
  # Check forecasts
  for (index in 1:2) {
    if (!(is.array(x[[names.to.check[index]]]) &&
          is.numeric(x[[names.to.check[index]]]) &&
          length(dim(x[[names.to.check[index]]])) == 4)) {
      cat('Error:', names.to.check[index], 'should be a 4-dimensional numeric array!\n')
      cat('Please use dim(), is.numeric(), and is.array() to check!\n')
      valid <- F
    }
  }
  
  # Check forecast times
  for (index in 3:4) {
    if (!(is.vector(x[[names.to.check[index]]], mode = 'numeric') &&
          length(x[[names.to.check[index]]]) == dim(x[[names.to.check[index-2]]])[3])) {
      cat('Error:', names.to.check[index], 'should be a numeric vector with the length of',
          'the third dimension of', names.to.check[index-2], '!\n')
      cat('Please use is.vector() and length() to check!\n')
      valid <- F
    }
    
  	# Append the name suffix to get the member name for test/search times to compare
    name <- paste(names(names.to.check)[index], '_compare', sep = '')
    
    if (!(is.vector(x[[name]]) &&
          is.numeric(x[[name]]))) {
      cat('Error:', name, 'should be a numeric vector!\n')
      cat('Please use is.vector() and is.numeric() to check!\n')
      valid <- F
    }
    
    if (!all(x[[name]] %in% x[[names.to.check[index]]])) {
      cat('Error: Some', name, 'cannot be found in', names.to.check[index], '.\n')
      valid <- F
    } 
  }
  
  # Check FLTs
  if (!(is.vector(x$flts, mode = 'numeric') &&
        length(x$flts) == dim(x[[names.to.check['search_forecasts']]])[4])) {
    cat('Error: FLTs should be a numeric vector with the length of the fourth dimension of forecasts!\n')
    cat('Please use is.vector() and length() to check!\n')
    valid <- F
  }
  
  # Check observations
  if (!(is.array(x$search_observations) &&
        is.numeric(x$search_observations) &&
        length(dim(x$search_observations)) == 3)) {
    cat('Error: Search observations should be a 3-dimensional numeric array!\n')
    cat('Please use dim(), is.numeric(), and is.array() to check!\n')
    valid <- F
  }
  
  # Check observation times
  if (!(is.vector(x$observation_times, mode = 'numeric') && 
        length(x$observation_times) == dim(x$search_observations)[3])) {
    cat('Error: Search observation times should be a numeric vector with',
        'the length of the third dimension of search observations!\n')
    cat('Please use is.vector() and length() to check!\n')
    valid <- F
  }
  
  # Check observation ID
  if (!(x$observation_id <= dim(x$search_observations)[1] &&
        is.numeric(x$observation_id) &&
        length(x$observation_id) == 1 &&
        x$observation_id >= 1)) {
    cat('Error: Observation id should be the index of the variable to use in observations.\n')
    valid <- F
  }
  
  # Check circular variable settings
  if (anyNA(x$circulars)) {
    cat('Error: Circular variable does not allow NA variables.\n')
    valid <- F

  } else {
    if (!(is.vector(x$circulars, mode = 'numeric') &&
          length(x$circulars) <= dim(x[[names.to.check['test_forecasts']]])[1])) {
      cat('Error: Circulars should be a numeric vector.',
          'Its length should not exceed the number of forecast variables.\n')
      valid <- F
    }
    
    for (val in x$circulars) {
      if (val > dim(x[[names.to.check['test_forecasts']]])[1] || val <= 0) {
        cat('Error: Circular values should belong to [ 1 ,',
            dim(x[[names.to.check['test_forecasts']]])[1], '].\n')
        valid <- F
      }
    }
  }
  
  # Check weights
  if (!(length(x$weights) == dim(x[[names.to.check['test_forecasts']]])[1] &&
        is.numeric(x$weights) &&
        is.vector(x$weights) &&
        !anyNA(x$weights))) {
    cat('Error: Weights should be a non-NA numeric vector of the length of the first dimension of',
        names.to.check['test_forecasts'], '.\nPlease use is.numeric and is.vector to check.\n')
    valid <- F
  }
  
  if (!is.logical(x$operational)) {
    cat("Error: Operational should be a boolean.\n")
    valid <- F
  }
  
  if (x$mode == 'extendedSearch') {
    
  	# Check test/search stations x/y
    for (index in 5:8) {
      name <- names.to.check[which(names(names.to.check) == 'test_forecasts')]
      	
      if (!(is.vector(x[[names.to.check[index]]], mode = 'numeric') &&
            length(x[[names.to.check[index]]]) == dim(x[[name]])[2])) {
        cat('Error:', names.to.check[index], 'should be a numeric vector with the',
            'length of the second dimension of', name, '!\n')
        cat('Please use is.vector() and length() to check!\n')
        valid <- F
      }
    }
    
  	# Check neighbor settings
    if (x$distance != 0) {
      if (x$num_nearest == 0) {
        if (x$max_num_search_stations == 0) {
          cat("Error: Please set the maximum number of search stations to keep within the distance.\n")
          valid <- F
        }
      } else {
        x$max_num_search_stations <- x$num_nearest
      }
    }
    
    if (!(is.logical(x$preserve_search_stations) && length(x$preserve_search_stations) == 1)) {
      cat('Error: preserve_search_stations should be a boolean.\n')
      valid <- F
    }
  }

  return (valid)
}
