<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnalogEnsemble: 2019-02-12-operational-search</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AnalogEnsemble
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">2019-02-12-operational-search </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> layout: post title: Operational Search with RAnEn tags: </p><h2>- tutorial </h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-description">Data Description</a></li>
<li><a href="#generate-temperature-forecasts">Generate Temperature Forecasts</a></li>
<li><a href="#visualization">Visualization</a></li>
</ul>
<h2>Introduction </h2>
<p>The prediction accuracy of Analog Ensemble depends on the quality of analogs. Presumably, better analogs will generate better predictions. In real-time model operation, when historical forecasts increasing and the test forecast moving forward in time, it is most likely that the historical forecasts in the near past are the most similar ones. Therefore, in an operational prediction mode, it is desired to increment the search forecasts when test forecasts are moving towards the future.</p>
<p>This article shows an example of how to use <code>RAnEn</code> with an operational search. It is strongly suggested to go over the <a href="https://weiming-hu.github.io/AnalogsEnsemble/2018/11/04/demo-1-RAnEn-basics.html">demo 1</a> prior to this tutorial.</p>
<h2>Data Description </h2>
<p>Same data are used from the <a href="https://weiming-hu.github.io/AnalogsEnsemble/2018/11/04/demo-1-RAnEn-basics.html">demo 1</a>.</p>
<div class="fragment"><div class="line">load(&#39;analysis.RData&#39;)</div><div class="line">load(&#39;forecasts.RData&#39;)</div><div class="line"></div><div class="line"># Only use one parameter, the surface temperature</div><div class="line">forecasts &lt;- forecasts[1, , , , drop = F]</div><div class="line"></div><div class="line">print(ls())</div></div><!-- fragment --> <pre class="fragment">##  [1] "analysis"               "analysis.circular.pars"
##  [3] "analysis.indices"       "analysis.par.names"    
##  [5] "analysis.times"         "analysis.xs"           
##  [7] "analysis.ys"            "flts"                  
##  [9] "forecast.circular.pars" "forecast.indices"      
## [11] "forecast.par.names"     "forecast.times"        
## [13] "forecast.xs"            "forecast.ys"           
## [15] "forecasts"
</pre><h2>Generate Temperature <a class="el" href="class_forecasts.html" title="Forecasts class provides interface for reading and writing forecast data from and to a NetCDF file...">Forecasts</a> </h2>
<p>When generating forecasts with an operational search, we need to pay attention to two sets of configuration parameters:</p>
<ul>
<li><code>test_times</code> and <code>search_times</code>: These two parameters are the complete and the largest sets of test/search times that will be possibly generated and used. And these two parameters should be consistent with the number of times in test/search forecasts.</li>
<li><code>test_times_compare</code> and <code>search_times_compare</code>: These two parameters are the actual test/search times that will be compared and simialrity will be generated for each combination of <code>test_times_compare</code> and <code>search_search_compare</code>. <b>However, if the operational search is desired, <code>search_search_compare</code> becomes meaningless because each test time will have a different set of search times, and search times will be regenerated for each test times. The generated search times will be a subset of or equal to <code>search_times</code></b>.</li>
</ul>
<p>If you don't understand any of the options, please see the <a href="https://weiming-hu.github.io/AnalogsEnsemble/R/reference/generateConfiguration.html">document</a>.</p>
<p>We then generate analogs.</p>
<div class="fragment"><div class="line">AnEn.opr &lt;- generateAnalogs(config)</div></div><!-- fragment --> <pre class="fragment">## Convert R objects to C++ objects ...
## Wrapping C++ object similarity matrix ...
## Wrapping C++ object mapping ...
## Wrapping C++ object analogs ...
## Done!
</pre><div class="fragment"><div class="line">AnEn.opr &lt;- biasCorrection(AnEn.opr, config, forecast.ID = 1, group.func = mean,</div><div class="line">                           na.rm = T, show.progress = F)</div></div><!-- fragment --><p>We generate another <a class="el" href="class_an_en.html" title="AnEn class provides interfaces for computing Analog Ensembles. ">AnEn</a> without operational search.</p>
<div class="fragment"><div class="line">search.start &lt;- 1</div><div class="line"></div><div class="line"># Remove the day to avoid overlapping between search and test forecasts</div><div class="line">search.end &lt;- test.start - 2</div><div class="line"></div><div class="line">config$operational &lt;- F</div><div class="line">config$search_times_compare &lt;- forecast.times[search.start:search.end]</div><div class="line">AnEn.ind &lt;- generateAnalogs(config)</div></div><!-- fragment --> <pre class="fragment">## Convert R objects to C++ objects ...
## Wrapping C++ object similarity matrix ...
## Wrapping C++ object mapping ...
## Wrapping C++ object analogs ...
## Done!
</pre><div class="fragment"><div class="line">AnEn.ind &lt;- biasCorrection(AnEn.ind, config, forecast.ID = 1, group.func = mean,</div><div class="line">                           na.rm = T, show.progress = F)</div></div><!-- fragment --><h2>Visualization </h2>
<p>We then compare the prediction accuracy on the last day in our test times.</p>
<div class="fragment"><div class="line"># Choose a FLT to plot</div><div class="line">i.flt &lt;- 31</div><div class="line"></div><div class="line"># Choose the last test time</div><div class="line">i.day &lt;- 5</div><div class="line"></div><div class="line"># Calculate ensemble means</div><div class="line">mean.analogs.opr.cor &lt;- apply(AnEn.opr$analogs.cor[, , , , 1, drop = F], c(1, 2, 3), mean, na.rm = T)</div><div class="line">mean.analogs.ind.cor &lt;- apply(AnEn.ind$analogs.cor[, , , , 1, drop = F], c(1, 2, 3), mean, na.rm = T)</div><div class="line"></div><div class="line"># Create an empty raster for the geographical region</div><div class="line">xy &lt;- cbind(as.numeric(forecast.xs) - 360, as.numeric(forecast.ys))</div><div class="line">colnames(xy) = c(&#39;x&#39;, &#39;y&#39;)</div><div class="line">ext &lt;- extent(xy[, c(&#39;x&#39;, &#39;y&#39;)])</div><div class="line">rast &lt;- raster(ext, nrow = 11, ncol = 11, crs = CRS(&quot;+proj=longlat +datum=WGS84&quot;))</div><div class="line"></div><div class="line"># Rasterize the data values</div><div class="line">rast.anen.opr.cor &lt;- rasterize(xy[, c(&#39;x&#39;, &#39;y&#39;)], rast, mean.analogs.opr.cor[, i.day, i.flt], fun = mean)</div><div class="line">rast.anen.ind.cor &lt;- rasterize(xy[, c(&#39;x&#39;, &#39;y&#39;)], rast, mean.analogs.ind.cor[, i.day, i.flt], fun = mean)</div><div class="line">rast.fcts &lt;- rasterize(xy[, c(&#39;x&#39;, &#39;y&#39;)], rast, forecasts[1, , test.start, i.flt], fun = mean)</div><div class="line">rast.anly &lt;- rasterize(xy[, c(&#39;x&#39;, &#39;y&#39;)], rast, analysis[</div><div class="line">  1, , which(analysis.times == forecast.times[test.start] + flts[i.flt])], fun = mean)</div><div class="line"></div><div class="line"># Calculate RMSE</div><div class="line">rmse.fcts &lt;- sqrt(mean((values(rast.fcts - rast.anly))^2, na.rm = T))</div><div class="line">rmse.anen.opr.cor &lt;- sqrt(mean((values(rast.anen.opr.cor - rast.anly))^2, na.rm = T))</div><div class="line">rmse.anen.ind.cor &lt;- sqrt(mean((values(rast.anen.ind.cor - rast.anly))^2, na.rm = T))</div><div class="line"></div><div class="line"># Create a color scale with 100 colors</div><div class="line">cols &lt;- colorRampPalette(brewer.pal(11, &#39;Spectral&#39;)[11:1])(100)</div><div class="line"></div><div class="line"># Define value limit</div><div class="line">zlim &lt;- range(c(values(rast.fcts), values(rast.anen.opr.cor),</div><div class="line">                values(rast.anly), values(rast.anen.ind.cor)),</div><div class="line">              na.rm = T)</div><div class="line"># Visualization</div><div class="line">par(mfrow = c(2, 2), mar = c(4, 1, 3, 3))</div><div class="line">plot(rast.anly, main = &#39;NAM Analysis&#39;, col = cols, zlim = zlim, legend = F)</div><div class="line">map(col = &#39;grey&#39;, add = T); map(&#39;state&#39;, add = T)</div><div class="line">plot(rast.fcts, main = &#39;NAM Forecasts&#39;, col = cols, zlim = zlim,</div><div class="line">     xlab = paste(&#39;RMSE =&#39;, round(rmse.fcts, 4)))</div><div class="line">map(col = &#39;grey&#39;, add = T); map(&#39;state&#39;, add = T)</div><div class="line">plot(rast.anen.ind.cor, main = &#39;AnEn Independent Search&#39;, col = cols, zlim = zlim,</div><div class="line">     legend = F, xlab = paste(&#39;RMSE =&#39;, round(rmse.anen.ind.cor, 4)))</div><div class="line">map(col = &#39;grey&#39;, add = T); map(&#39;state&#39;, add = T)</div><div class="line">plot(rast.anen.opr.cor, main = &#39;AnEn Operational Search&#39;, col = cols,</div><div class="line">     zlim = zlim, xlab = paste(&#39;RMSE =&#39;, round(rmse.anen.opr.cor, 4)))</div><div class="line">map(col = &#39;grey&#39;, add = T); map(&#39;state&#39;, add = T)</div></div><!-- fragment --><div class="image">
<img src="https://github.com/Weiming-Hu/AnalogsEnsemble/raw/gh-pages/assets/posts/2019-02-12-operational-search/unnamed-chunk-5-1.png" alt="Result comparison"/>
</div>
<p>If we take a closer look at the analog members of inependent search and operational search. The search times of independent search and the operational search for a specific test time are different. This is indeed the results from the operational search.</p>
<div class="fragment"><div class="line">cat(&#39;The closest analog member time to the test time&#39;, as.character(forecast.times[test.start + i.day - 1] + flts[i.flt]), &#39;:\n&#39;)</div></div><!-- fragment --> <pre class="fragment">## The closest analog member time to the test time 2018-03-09 06:00:00 :
</pre><div class="fragment"><div class="line">cat(&#39;(independent search) &#39;, as.character(analysis.times[range(AnEn.ind$analogs[, i.day, i.flt, , 3], na.rm = T)[2]]), &#39;\n&#39;)</div></div><!-- fragment --> <pre class="fragment">## (independent search)  2018-03-03 06:00:00
</pre><div class="fragment"><div class="line">cat(&#39;(operational search) &#39;, as.character(analysis.times[range(AnEn.opr$analogs[, i.day, i.flt, , 3], na.rm = T)[2]]), &#39;\n&#39;)</div></div><!-- fragment --> <pre class="fragment">## (operational search)  2018-03-07 06:00:00</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
