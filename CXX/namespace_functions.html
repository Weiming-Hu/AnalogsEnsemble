<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParallelAnalogEnsemble: Functions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ParallelAnalogEnsemble
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1a53efc30f777b3253fe8f0e7a54f30f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Matrix</a> = boost::numeric::ublas::matrix&lt; double, boost::numeric::ublas::column_major, std::vector&lt; double &gt; &gt;</td></tr>
<tr class="separator:a1a53efc30f777b3253fe8f0e7a54f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a79d3ee8a14fa3e0f399b7406120bda01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a79d3ee8a14fa3e0f399b7406120bda01">createObsMap</a> (std::unordered_map&lt; std::string, std::size_t &gt; &amp;map, const std::vector&lt; std::size_t &gt; &amp;id, const <a class="el" href="class_parameters.html">Parameters</a> &amp;)</td></tr>
<tr class="separator:a79d3ee8a14fa3e0f399b7406120bda01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccd3943539737c2cf0a3a98577cbf61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a0ccd3943539737c2cf0a3a98577cbf61">toValues</a> (<a class="el" href="class_array4_d.html">Array4D</a> &amp;, std::size_t, const <a class="el" href="class_array4_d.html">Array4D</a> &amp;, const <a class="el" href="class_observations.html">Observations</a> &amp;)</td></tr>
<tr class="separator:a0ccd3943539737c2cf0a3a98577cbf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc4891dcb71bc023e1100a5ccafabce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a5fc4891dcb71bc023e1100a5ccafabce">toValues</a> (<a class="el" href="class_array4_d.html">Array4D</a> &amp;, std::size_t, const <a class="el" href="class_array4_d.html">Array4D</a> &amp;, const <a class="el" href="class_array4_d.html">Array4D</a> &amp;, const <a class="el" href="class_observations.html">Observations</a> &amp;)</td></tr>
<tr class="separator:a5fc4891dcb71bc023e1100a5ccafabce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add93c68e401b4626f1169dd5be9fe5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#add93c68e401b4626f1169dd5be9fe5bf">setSearchStations</a> (const <a class="el" href="class_stations.html">Stations</a> &amp;, <a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Matrix</a> &amp;table, double)</td></tr>
<tr class="separator:add93c68e401b4626f1169dd5be9fe5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef74dd68e2c24bc7ce2d6f81cfc0c10"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#adef74dd68e2c24bc7ce2d6f81cfc0c10">findClosest</a> (const <a class="el" href="class_station.html">Station</a> &amp;station, const <a class="el" href="class_stations.html">Stations</a> &amp;stations)</td></tr>
<tr class="separator:adef74dd68e2c24bc7ce2d6f81cfc0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563398889c51cb5325e0211eb47b42b3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a563398889c51cb5325e0211eb47b42b3">findClosest</a> (const <a class="el" href="class_stations.html">Stations</a> &amp;targets, const <a class="el" href="class_stations.html">Stations</a> &amp;pool, <a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a> verbose)</td></tr>
<tr class="separator:a563398889c51cb5325e0211eb47b42b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9604a2b84f3af91add3e2ad677503af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a9604a2b84f3af91add3e2ad677503af3">itov</a> (int)</td></tr>
<tr class="separator:a9604a2b84f3af91add3e2ad677503af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cf199876092c0cead2a25773e53504"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a28cf199876092c0cead2a25773e53504">vtoi</a> (<a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>)</td></tr>
<tr class="separator:a28cf199876092c0cead2a25773e53504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8567a527538b0d921dda13622b6ac568"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a8567a527538b0d921dda13622b6ac568">vtos</a> (<a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>)</td></tr>
<tr class="separator:a8567a527538b0d921dda13622b6ac568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74848f0e55146e8eccd052ca71aff662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a74848f0e55146e8eccd052ca71aff662">updateTimeTable</a> (const <a class="el" href="class_times.html">Times</a> &amp;fcst_times, const std::vector&lt; std::size_t &gt; &amp;fcst_times_index, const <a class="el" href="class_times.html">Times</a> &amp;fcst_flts, const <a class="el" href="class_times.html">Times</a> &amp;obs_times, <a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Matrix</a> &amp;table)</td></tr>
<tr class="separator:a74848f0e55146e8eccd052ca71aff662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2015a2e06a7b904c16642dbccb1fc0b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a2015a2e06a7b904c16642dbccb1fc0b0">sdLinear</a> (const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="separator:a2015a2e06a7b904c16642dbccb1fc0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8808ce53e6d11da7bf947d8a5a36f5c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a8808ce53e6d11da7bf947d8a5a36f5c0">sdCircular</a> (const std::vector&lt; double &gt; &amp;degs)</td></tr>
<tr class="separator:a8808ce53e6d11da7bf947d8a5a36f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34621bf8696f9d8df2b70b6a999be91b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a34621bf8696f9d8df2b70b6a999be91b">sum</a> (const std::vector&lt; double &gt; &amp;values, std::size_t max_nan_allowed=_MAX_SIZE_T)</td></tr>
<tr class="separator:a34621bf8696f9d8df2b70b6a999be91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d106550db1089db89f6596738a4bea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#af9d106550db1089db89f6596738a4bea">mean</a> (const std::vector&lt; double &gt; &amp;values, std::size_t max_nan_allowed=_MAX_SIZE_T)</td></tr>
<tr class="separator:af9d106550db1089db89f6596738a4bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f64a829c246c78e2c215132e347c65"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a29f64a829c246c78e2c215132e347c65">sum</a> (const std::vector&lt; double &gt; &amp;values, const double max_nan_allowed=NAN)</td></tr>
<tr class="separator:a29f64a829c246c78e2c215132e347c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792b17d917560feaa7ac79d7fed2c16f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a792b17d917560feaa7ac79d7fed2c16f">variance</a> (const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="separator:a792b17d917560feaa7ac79d7fed2c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7588faf5c671515dd4dbf34f1f37bdb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aa7588faf5c671515dd4dbf34f1f37bdb">diffCircular</a> (double i, double j)</td></tr>
<tr class="separator:aa7588faf5c671515dd4dbf34f1f37bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57130b1aabce9d4eb91c64b88257da0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#ac57130b1aabce9d4eb91c64b88257da0">wind_speed</a> (double u, double v)</td></tr>
<tr class="separator:ac57130b1aabce9d4eb91c64b88257da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa207036879c57a14e60a0f086e134a72"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aa207036879c57a14e60a0f086e134a72">wind_dir</a> (double u, double v)</td></tr>
<tr class="separator:aa207036879c57a14e60a0f086e134a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb9bce40d7689c2c93021b991c5252b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aaeb9bce40d7689c2c93021b991c5252b">levenshtein</a> (const std::string &amp;str1, const std::string &amp;str2, size_t w=0, size_t s=2, size_t a=1, size_t d=3)</td></tr>
<tr class="separator:aaeb9bce40d7689c2c93021b991c5252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b5fb932ba5fd5218fbb207e9edd78"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#ab01b5fb932ba5fd5218fbb207e9edd78">toSeconds</a> (const std::string &amp;datetime_str, const std::string &amp;origin_str, bool iso_string)</td></tr>
<tr class="separator:ab01b5fb932ba5fd5218fbb207e9edd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdb18407c68ff2b1029eb3a2a6a868d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#abbdb18407c68ff2b1029eb3a2a6a868d">collapseLeadTimes</a> (<a class="el" href="class_observations.html">Observations</a> &amp;, const <a class="el" href="class_forecasts.html">Forecasts</a> &amp;)</td></tr>
<tr class="separator:abbdb18407c68ff2b1029eb3a2a6a868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68645938b9a74651ec9ad2cefe5c2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#ab68645938b9a74651ec9ad2cefe5c2be">unwrapTimeSeries</a> (<a class="el" href="class_forecasts.html">Forecasts</a> &amp;, const <a class="el" href="class_times.html">Times</a> &amp;, const <a class="el" href="class_times.html">Times</a> &amp;, const <a class="el" href="class_observations.html">Observations</a> &amp;)</td></tr>
<tr class="separator:ab68645938b9a74651ec9ad2cefe5c2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa836cecd645caec313c880481db5e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aefa836cecd645caec313c880481db5e5">randomizeForecasts</a> (<a class="el" href="class_forecasts.html">Forecasts</a> &amp;fcsts, double nan_prob, size_t min_valid_count=0)</td></tr>
<tr class="separator:aefa836cecd645caec313c880481db5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64c4a81e0a15667232be924b2899f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aa64c4a81e0a15667232be924b2899f51">randomizeObservations</a> (<a class="el" href="class_observations.html">Observations</a> &amp;obs, double nan_prob)</td></tr>
<tr class="separator:aa64c4a81e0a15667232be924b2899f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f73a965fe4074516232de0e85b657c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a79f73a965fe4074516232de0e85b657c">getStartIndex</a> (int total, int num_procs, int rank)</td></tr>
<tr class="separator:a79f73a965fe4074516232de0e85b657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7610a3ca47370ffe5104bba97bea732f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a7610a3ca47370ffe5104bba97bea732f">getEndIndex</a> (int total, int num_procs, int rank)</td></tr>
<tr class="separator:a7610a3ca47370ffe5104bba97bea732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c0a68fb8243e0106b18ba09ae3c1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_functions.html#aaf2c0a68fb8243e0106b18ba09ae3c1f">getSubTotal</a> (int grand_total, int num_procs, int rank)</td></tr>
<tr class="separator:aaf2c0a68fb8243e0106b18ba09ae3c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c66283d4d64dd80f44fdef1817447e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58c66283d4d64dd80f44fdef1817447e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_functions.html#a58c66283d4d64dd80f44fdef1817447e">format</a> (const std::vector&lt; T &gt; &amp;vec, const std::string &amp;delim=&quot;,&quot;, std::size_t preview=5)</td></tr>
<tr class="separator:a58c66283d4d64dd80f44fdef1817447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806989cf9beae4ffe41001a2072ae55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af806989cf9beae4ffe41001a2072ae55"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_functions.html#af806989cf9beae4ffe41001a2072ae55">format</a> (const T *ptr, std::size_t len, const std::string &amp;delim=&quot;,&quot;, std::size_t preview=5)</td></tr>
<tr class="separator:af806989cf9beae4ffe41001a2072ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f2c7da969414ed7e5f13b672191288"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac7f2c7da969414ed7e5f13b672191288"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_functions.html#ac7f2c7da969414ed7e5f13b672191288">toIndex</a> (std::vector&lt; std::size_t &gt; &amp;index, const T &amp;query, const T &amp;pool)</td></tr>
<tr class="separator:ac7f2c7da969414ed7e5f13b672191288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa120d594f9ce152d0aa1a4bd7b4e7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adfa120d594f9ce152d0aa1a4bd7b4e7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_functions.html#adfa120d594f9ce152d0aa1a4bd7b4e7b">guess_arguments</a> (const std::vector&lt; std::basic_string&lt; T &gt; &gt; &amp;unregistered_keys, const std::vector&lt; std::string &gt; &amp;available_options, std::ostream &amp;os)</td></tr>
<tr class="separator:adfa120d594f9ce152d0aa1a4bd7b4e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1a53efc30f777b3253fe8f0e7a54f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a53efc30f777b3253fe8f0e7a54f30f">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Functions::Matrix</a> = typedef boost::numeric::ublas::matrix&lt; double, boost::numeric::ublas::column_major, std::vector&lt;double&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Matrix type is from boost uBLAS matrix.</p>
<p>It is a double matrix because it needs to be ablt to hold NAN.</p>
<p>Its internal storage is in column major because it is easier to be converted to an R structure and for file I/O with file formats like NetCDF.</p>
<p>The storage type is std::vector because the default storage type, unbounded_array, does not model sequence operators. Using vectors will make it easier for value initialization. Some basic profiling has shown that the creation will be slightly slower, but the indexing will be slightly faster when std::vector is used. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abbdb18407c68ff2b1029eb3a2a6a868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdb18407c68ff2b1029eb3a2a6a868d">&#9670;&nbsp;</a></span>collapseLeadTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::collapseLeadTimes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_observations.html">Observations</a> &amp;&#160;</td>
          <td class="paramname"><em>observations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_forecasts.html">Forecasts</a> &amp;&#160;</td>
          <td class="paramname"><em>forecasts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse the time and lead time dimensions of a forecasts and convert them to observations; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a></td><td><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a> to store results </td></tr>
    <tr><td class="paramname"><a class="el" href="class_forecasts.html" title="Forecasts is an abstract class that extends BasicData and the abstract class Array4D. It defines the interface of how to interact with the underlying data storage through the abstract class Array4D. This interface is accepted by the Analog Ensemble algorithm. ">Forecasts</a></td><td><a class="el" href="class_forecasts.html" title="Forecasts is an abstract class that extends BasicData and the abstract class Array4D. It defines the interface of how to interact with the underlying data storage through the abstract class Array4D. This interface is accepted by the Analog Ensemble algorithm. ">Forecasts</a> to be collapsed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79d3ee8a14fa3e0f399b7406120bda01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d3ee8a14fa3e0f399b7406120bda01">&#9670;&nbsp;</a></span>createObsMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::createObsMap </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_parameters.html">Parameters</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an unordered map with parameter names as keys and the id as values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs_map</td><td>An unordered map </td></tr>
    <tr><td class="paramname">obs_id</td><td>Vectors with variables ID </td></tr>
    <tr><td class="paramname">parameters</td><td><a class="el" href="class_parameters.html" title="Parameters class stores Parameter objects. It is a bidirectional map implemented from Boost so that i...">Parameters</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7588faf5c671515dd4dbf34f1f37bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7588faf5c671515dd4dbf34f1f37bdb">&#9670;&nbsp;</a></span>diffCircular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::diffCircular </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the difference of two circular numbers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>A double. </td></tr>
    <tr><td class="paramname">j</td><td>A double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double. </dd></dl>

</div>
</div>
<a id="adef74dd68e2c24bc7ce2d6f81cfc0c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef74dd68e2c24bc7ce2d6f81cfc0c10">&#9670;&nbsp;</a></span>findClosest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Functions::findClosest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_station.html">Station</a> &amp;&#160;</td>
          <td class="paramname"><em>station</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_stations.html">Stations</a> &amp;&#160;</td>
          <td class="paramname"><em>stations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the index of the closest station. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td>The target station </td></tr>
    <tr><td class="paramname">stations</td><td>The pool of stations to search from  verbose Verbose level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index of the closest station from the pool </dd></dl>

</div>
</div>
<a id="a563398889c51cb5325e0211eb47b42b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563398889c51cb5325e0211eb47b42b3">&#9670;&nbsp;</a></span>findClosest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; Functions::findClosest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stations.html">Stations</a> &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_stations.html">Stations</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58c66283d4d64dd80f44fdef1817447e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c66283d4d64dd80f44fdef1817447e">&#9670;&nbsp;</a></span>format() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Functions::format </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>preview</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format a vector as a string for printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector </td></tr>
    <tr><td class="paramname">len</td><td>Length of the pointed object </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer </td></tr>
    <tr><td class="paramname">delim</td><td>A string deliminator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string </dd></dl>

</div>
</div>
<a id="af806989cf9beae4ffe41001a2072ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af806989cf9beae4ffe41001a2072ae55">&#9670;&nbsp;</a></span>format() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Functions::format </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>preview</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7610a3ca47370ffe5104bba97bea732f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7610a3ca47370ffe5104bba97bea732f">&#9670;&nbsp;</a></span>getEndIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Functions::getEndIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79f73a965fe4074516232de0e85b657c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f73a965fe4074516232de0e85b657c">&#9670;&nbsp;</a></span>getStartIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Functions::getStartIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespace_functions.html">Functions</a> to calculate indices to split a consecutive vector. These are designed for MPI tasks. The rank 0 is considered as the master process. So there will be num_procs - 1 chunks to be distributed. </p>

</div>
</div>
<a id="aaf2c0a68fb8243e0106b18ba09ae3c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c0a68fb8243e0106b18ba09ae3c1f">&#9670;&nbsp;</a></span>getSubTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Functions::getSubTotal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>grand_total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfa120d594f9ce152d0aa1a4bd7b4e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa120d594f9ce152d0aa1a4bd7b4e7b">&#9670;&nbsp;</a></span>guess_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Functions::guess_arguments </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::basic_string&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>unregistered_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>available_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Guess the unregistered parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unregistered_keys</td><td>The unregistered keys returned by boost::program_options::collect_unrecognized. </td></tr>
    <tr><td class="paramname">available_options</td><td>A vector of string for available options. </td></tr>
    <tr><td class="paramname">os</td><td>An output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9604a2b84f3af91add3e2ad677503af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9604a2b84f3af91add3e2ad677503af3">&#9670;&nbsp;</a></span>itov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a> Functions::itov </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an integer to Verbose and vice versa</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">An</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Verbose </dd></dl>

</div>
</div>
<a id="aaeb9bce40d7689c2c93021b991c5252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb9bce40d7689c2c93021b991c5252b">&#9670;&nbsp;</a></span>levenshtein()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Functions::levenshtein </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>w</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the Levenshtein distance of two strings. The function can be used to guess the intended argument of an unknown one. This function is used by the function <a class="el" href="namespace_functions.html#adfa120d594f9ce152d0aa1a4bd7b4e7b">Functions::guess_arguments</a>.</p>
<p>The implementation is referenced from Github <a href="https://github.com/git/git/blob/master/levenshtein.h">https://github.com/git/git/blob/master/levenshtein.h</a></p>
<p>Thanks to the pointer of Vlad Lazarenko <a href="http://lazarenko.me/smart-getopt/">http://lazarenko.me/smart-getopt/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>A string. </td></tr>
    <tr><td class="paramname">str2</td><td>A string. </td></tr>
    <tr><td class="paramname">w</td><td>Weight suggested by GitHub. </td></tr>
    <tr><td class="paramname">s</td><td>Weight suggested by GitHub. </td></tr>
    <tr><td class="paramname">a</td><td>Weight suggested by GitHub. </td></tr>
    <tr><td class="paramname">d</td><td>Weight suggested by GitHub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distance measure </dd></dl>

</div>
</div>
<a id="af9d106550db1089db89f6596738a4bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d106550db1089db89f6596738a4bea">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_nan_allowed</em> = <code>_MAX_SIZE_T</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the mean of a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of values. </td></tr>
    <tr><td class="paramname">max_nan_allowed</td><td>The number of NAN values allowed in the vector. Set it to NAN to allow any number of NAN values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefa836cecd645caec313c880481db5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa836cecd645caec313c880481db5e5">&#9670;&nbsp;</a></span>randomizeForecasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::randomizeForecasts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_forecasts.html">Forecasts</a> &amp;&#160;</td>
          <td class="paramname"><em>fcsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nan_prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_valid_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize forecasts or observations with random values. These functions are used for testing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcsts</td><td><a class="el" href="class_forecasts.html" title="Forecasts is an abstract class that extends BasicData and the abstract class Array4D. It defines the interface of how to interact with the underlying data storage through the abstract class Array4D. This interface is accepted by the Analog Ensemble algorithm. ">Forecasts</a> </td></tr>
    <tr><td class="paramname">nan_prob</td><td>The portion of NAN values </td></tr>
    <tr><td class="paramname">min_valid_count</td><td>the minimum number of valid values in times </td></tr>
    <tr><td class="paramname">obs</td><td><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa64c4a81e0a15667232be924b2899f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64c4a81e0a15667232be924b2899f51">&#9670;&nbsp;</a></span>randomizeObservations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::randomizeObservations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_observations.html">Observations</a> &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nan_prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8808ce53e6d11da7bf947d8a5a36f5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8808ce53e6d11da7bf947d8a5a36f5c0">&#9670;&nbsp;</a></span>sdCircular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::sdCircular </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>degs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the standard deviation for angles in degree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2015a2e06a7b904c16642dbccb1fc0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2015a2e06a7b904c16642dbccb1fc0b0">&#9670;&nbsp;</a></span>sdLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::sdLinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the standard deviation for linear numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add93c68e401b4626f1169dd5be9fe5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add93c68e401b4626f1169dd5be9fe5bf">&#9670;&nbsp;</a></span>setSearchStations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::setSearchStations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stations.html">Stations</a> &amp;&#160;</td>
          <td class="paramname"><em>stations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the search stations based on distance and nearest neighbors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stations</td><td><a class="el" href="class_stations.html" title="Stations class stores Station objects. It is a bidirectional map implemented from Boost so that it pr...">Stations</a> to find neighbors </td></tr>
    <tr><td class="paramname">table</td><td>An index table. Each row shows the indices for neighbor stations of a particular station in <a class="el" href="class_stations.html" title="Stations class stores Station objects. It is a bidirectional map implemented from Boost so that it pr...">Stations</a>. </td></tr>
    <tr><td class="paramname">distance</td><td>Distance threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34621bf8696f9d8df2b70b6a999be91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34621bf8696f9d8df2b70b6a999be91b">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_nan_allowed</em> = <code>_MAX_SIZE_T</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f64a829c246c78e2c215132e347c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f64a829c246c78e2c215132e347c65">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_nan_allowed</em> = <code>NAN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the sum of a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of values. </td></tr>
    <tr><td class="paramname">max_nan_allowed</td><td>The number of NAN values allowed in the vector. Set it to NAN to allow any number of NAN values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f2c7da969414ed7e5f13b672191288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f2c7da969414ed7e5f13b672191288">&#9670;&nbsp;</a></span>toIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Functions::toIndex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the indices for each query object from the pool objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A vector to store indices. </td></tr>
    <tr><td class="paramname">query</td><td>Objects to query. It can be <a class="el" href="class_parameters.html" title="Parameters class stores Parameter objects. It is a bidirectional map implemented from Boost so that i...">Parameters</a>, <a class="el" href="class_times.html" title="Times class is used to store Time. It is a bidirectional map implemented from Boost so that it provid...">Times</a>, <a class="el" href="class_stations.html" title="Stations class stores Station objects. It is a bidirectional map implemented from Boost so that it pr...">Stations</a>. </td></tr>
    <tr><td class="paramname">pool</td><td>Objects from which indices are generated. It can be <a class="el" href="class_parameters.html" title="Parameters class stores Parameter objects. It is a bidirectional map implemented from Boost so that i...">Parameters</a>, <a class="el" href="class_times.html" title="Times class is used to store Time. It is a bidirectional map implemented from Boost so that it provid...">Times</a>, <a class="el" href="class_stations.html" title="Stations class stores Station objects. It is a bidirectional map implemented from Boost so that it pr...">Stations</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab01b5fb932ba5fd5218fbb207e9edd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b5fb932ba5fd5218fbb207e9edd78">&#9670;&nbsp;</a></span>toSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Functions::toSeconds </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>datetime_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>origin_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iso_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a date time string to the number of seconds since origin time.</p>
<p>The format should follow the section 'Construct from String' from here <a href="https://www.boost.org/doc/libs/1_72_0/doc/html/date_time/posix_time.html">https://www.boost.org/doc/libs/1_72_0/doc/html/date_time/posix_time.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datetime_str</td><td>A date time string for start time </td></tr>
    <tr><td class="paramname">origin_str</td><td>A date time string for the original time </td></tr>
    <tr><td class="paramname">iso_string</td><td>Whether the string is in ISO format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of seconds since the origin; </dd></dl>

</div>
</div>
<a id="a0ccd3943539737c2cf0a3a98577cbf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccd3943539737c2cf0a3a98577cbf61">&#9670;&nbsp;</a></span>toValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::toValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_array4_d.html">Array4D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array4_d.html">Array4D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_observations.html">Observations</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts analogs time index to analogs value using the specified observation ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">analogs</td><td>Analogs for storing values </td></tr>
    <tr><td class="paramname">obs_id</td><td>Observation ID </td></tr>
    <tr><td class="paramname">analogs_time_index</td><td>Analogs time index from <a class="el" href="class_an_en.html" title="AnEn is an abstract class that defines the interface for implement analog ensemble generation...">AnEn</a> </td></tr>
    <tr><td class="paramname">analogs_station_index</td><td>Analogs station index from <a class="el" href="class_an_en.html" title="AnEn is an abstract class that defines the interface for implement analog ensemble generation...">AnEn</a>. This is usually the similarity station index because they are the same. </td></tr>
    <tr><td class="paramname">observations</td><td><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc4891dcb71bc023e1100a5ccafabce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc4891dcb71bc023e1100a5ccafabce">&#9670;&nbsp;</a></span>toValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::toValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_array4_d.html">Array4D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array4_d.html">Array4D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array4_d.html">Array4D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_observations.html">Observations</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab68645938b9a74651ec9ad2cefe5c2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68645938b9a74651ec9ad2cefe5c2be">&#9670;&nbsp;</a></span>unwrapTimeSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::unwrapTimeSeries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_forecasts.html">Forecasts</a> &amp;&#160;</td>
          <td class="paramname"><em>forecasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_times.html">Times</a> &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_times.html">Times</a> &amp;&#160;</td>
          <td class="paramname"><em>flts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_observations.html">Observations</a> &amp;&#160;</td>
          <td class="paramname"><em>observations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unwrap the times series of observations to reconstruct forecast times and lead times. This is the reverse process of <code>collapseLeadTimes</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_forecasts.html" title="Forecasts is an abstract class that extends BasicData and the abstract class Array4D. It defines the interface of how to interact with the underlying data storage through the abstract class Array4D. This interface is accepted by the Analog Ensemble algorithm. ">Forecasts</a></td><td><a class="el" href="class_forecasts.html" title="Forecasts is an abstract class that extends BasicData and the abstract class Array4D. It defines the interface of how to interact with the underlying data storage through the abstract class Array4D. This interface is accepted by the Analog Ensemble algorithm. ">Forecasts</a> to store results </td></tr>
    <tr><td class="paramname">times</td><td>Forecast times to reconstruct </td></tr>
    <tr><td class="paramname">flts</td><td>Forecast lead times to reconstruct </td></tr>
    <tr><td class="paramname"><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a></td><td><a class="el" href="class_observations.html" title="Observations is an abstract class that extends BasicData. It defines the interface of how to interact...">Observations</a> to be unwrapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74848f0e55146e8eccd052ca71aff662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74848f0e55146e8eccd052ca71aff662">&#9670;&nbsp;</a></span>updateTimeTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Functions::updateTimeTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_times.html">Times</a> &amp;&#160;</td>
          <td class="paramname"><em>fcst_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>fcst_times_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_times.html">Times</a> &amp;&#160;</td>
          <td class="paramname"><em>fcst_flts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_times.html">Times</a> &amp;&#160;</td>
          <td class="paramname"><em>obs_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_functions.html#a1a53efc30f777b3253fe8f0e7a54f30f">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes a lookup table which maps from forecast time and lead time indices to observation time indices. If the observation time index is not found, the cell value in the table will stay untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcst_times</td><td>Forecast <a class="el" href="class_times.html" title="Times class is used to store Time. It is a bidirectional map implemented from Boost so that it provid...">Times</a>. </td></tr>
    <tr><td class="paramname">fcst_times_index</td><td>The indices to compute mapping. </td></tr>
    <tr><td class="paramname">fcst_flts</td><td>Forecast FLTs. </td></tr>
    <tr><td class="paramname">obs_times</td><td>Observation <a class="el" href="class_times.html" title="Times class is used to store Time. It is a bidirectional map implemented from Boost so that it provid...">Times</a>. </td></tr>
    <tr><td class="paramname">table</td><td>A matrix storing the indices with forecast times in rows and forecast lead times in columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a792b17d917560feaa7ac79d7fed2c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792b17d917560feaa7ac79d7fed2c16f">&#9670;&nbsp;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::variance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the variance of a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of values. </td></tr>
    <tr><td class="paramname">average</td><td>The average of input values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28cf199876092c0cead2a25773e53504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cf199876092c0cead2a25773e53504">&#9670;&nbsp;</a></span>vtoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Functions::vtoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8567a527538b0d921dda13622b6ac568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8567a527538b0d921dda13622b6ac568">&#9670;&nbsp;</a></span>vtos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Functions::vtos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_config_8h.html#ab95b2bf068cfe461f5b13a95191219a9">Verbose</a>&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa207036879c57a14e60a0f086e134a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa207036879c57a14e60a0f086e134a72">&#9670;&nbsp;</a></span>wind_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::wind_dir </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac57130b1aabce9d4eb91c64b88257da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57130b1aabce9d4eb91c64b88257da0">&#9670;&nbsp;</a></span>wind_speed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Functions::wind_speed </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate wind speed and direction from U and V components. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>U component value </td></tr>
    <tr><td class="paramname">v</td><td>V component value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wind speed or direction value </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
